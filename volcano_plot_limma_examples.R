library(biomaRt)
library(limma)
library(ggplot2)
library(ggrepel)

mart_p <- useMart('ENSEMBL_MART_ENSEMBL')
mart_p <- useDataset('hsapiens_gene_ensembl', mart_p)
# uniprot names is all uniprots across entire dataset

# Change these paths to point to wherever you store the proteomics and metadata
proteomics = read.csv('~/Documents/fraenkel/proteomics/proteomics_clean/normalized_imp_corrected_proteomics204_03292022.csv',
                      row.names=1)
small_metadata = read.csv('~/Documents/fraenkel/proteomics/proteomics_clean/full_prot_metadata203_03082023.csv', 
                          row.names=1)
# Drop extreme outlier subject (FGT)
proteomics = proteomics[,small_metadata$GUID]

uniprot_names = sapply(row.names(proteomics), function(x) {
  strsplit(x, '[_|]')[[1]][1]
})

prot_trans = getBM(
  mart = mart_p,
  attributes = c(
    'ensembl_gene_id',
    'gene_biotype',
    'external_gene_name',
    'uniprot_gn_symbol',
    'uniprot_gn_id', 
    'chromosome_name',
    'start_position',
    'end_position',
    'description'),
  filter = 'uniprot_gn_id',
  values = uniprot_names,
  uniqueRows = TRUE)


# Function to generate volcano plot from limma based differential expression 
# results table 
# results_table has format matching output of limma::topTable() function (see example)
# Note that limma automatically computes logFC between two comparison groups
# prot_trans_table has format matching output of getBM()

# Feel free to modify this function to take in results generated by other diff.
# exp procedure (like DESeq2)

volcano_limma = function(results_table, prot_trans_table, ylim=NULL,
                         text_size=20, label_size=4, adjp_threshold = 0.1,
                         return.plot = F, return.table = F) {
  
  results_table[['neglog_qval']] = -log10(results_table$adj.P.Val)
  results_table[['sign_sign']] = as.character(results_table$adj.P.Val < adjp_threshold)
  results_table[['sign_sign2']] = results_table$adj.P.Val < adjp_threshold
  results_table[results_table$sign_sign2 & results_table$logFC > 0, 
                'sign_sign'] = 'POS'
  results_table[results_table$sign_sign2 & results_table$logFC < 0, 
                'sign_sign'] = 'NEG'
  
  
  orig_prot_names = row.names(results_table)
  
  # remove either if there has been processing of the names
  results_uniprot = sapply(row.names(results_table), function(x) {
    strsplit(x, '[_|]')[[1]][1]
  })
  
  row.names(results_table) = results_uniprot
  names(orig_prot_names) = results_uniprot
  
  dep_prot_trans1 = prot_trans_table[prot_trans_table$uniprot_gn_id %in% results_uniprot,]
  dep_prot_trans1 = dep_prot_trans1[!duplicated(dep_prot_trans1$uniprot_gn_id),]
  
  # Add warning if DEPs are missing from biomart table
  # TODO: get uniprot info from other package perhaps 
  missing = setdiff(results_uniprot, dep_prot_trans1$uniprot_gn_id)
  if (length(missing) > 0) {
    warning(paste0(length(missing), ' uniprot IDs not found'))
  }
  
  row.names(dep_prot_trans1) = dep_prot_trans1$uniprot_gn_id
  results_table[['name']] = ''
  results_table[results_uniprot, 'name'] = dep_prot_trans1[results_uniprot, 
                                                           'uniprot_gn_symbol']
  results_table[missing, 'name'] = orig_prot_names[missing]
  
  # Make plot 
  gplot = ggplot(results_table, aes(x=logFC, y=neglog_qval, col=sign_sign)) +
    geom_point() + geom_hline(yintercept = -log10(adjp_threshold), linetype=2) +
    geom_vline(xintercept = 0) + 
    theme(legend.position = "none", text=element_text(size=text_size)) +
    scale_color_manual(values = c('POS' = "red", 'FALSE' = "grey",
                                  'NEG' = 'blue')) +
    xlab('Log2FC') + ylab('-Log10(adj. p-value)') 
  
  if (!is.null(ylim)) {
    gplot = gplot + ylim(ylim)
  }
  
  gplot = gplot + ggrepel::geom_text_repel(data = filter(results_table, sign_sign2), 
                                           aes(label = name), 
                                           size = label_size, 
                                           box.padding = 0.5,
                                           max.overlaps = 20,
                                           min.segment.length = 0)
  if (return.plot) {
    return(gplot)
  }
  if (return.table) {
    return(results_table)
  }
  print(gplot)
}

# Examples running function

# Read in limma results table 
limma_results = read.csv('~/Documents/fraenkel/urop_resources/example_limma_result.csv', row.names=1)

# and also for subtype vs. ALS comparison with s100b + other staining marker covariates
volcano_limma(results_table = limma_results, prot_trans_table = prot_trans)


#####################################################################################
#####################################################################################
# Example running limma on proteomics data (not needed for volcano plot generation in general)

# Function to perform differential expression on normalized proteomics data
# taking both continuous and discrete covariates into account 

# covars indicates which columns to use as covariates when computing differential 
# expression
# comp_variable indicates which column should be used to split samples into comparison groups
# contrast_pass indicates which values to use in comp_variable column when making comparisons (must be in this format)

# subset.col is for subsetting all subjects to particular set before running comparison
getLimmaResults = function(norm_assay, metadata, comp_variable = 'Case',
                           covars = c('Sex', 's100b'),
                           contrast_pass = 'fCASE-fCTRL', subset.col = NA,
                           subset.accept = NA) {
  
  # subset down if needed for certain comparisons
  if (!is.na(subset.col)) {
    print(paste0('Using only ', subset.accept, ' in ', subset.col, ' column'))
    metadata = metadata[metadata[[subset.col]] %in% subset.accept,]
    # double check NAs
    metadata = metadata[!is.na(metadata[[subset.col]]),]
    
    norm_assay = norm_assay[,metadata$GUID]
  }
  
  # first make sure all covariates have no missing values
  orig_size = nrow(metadata)
  if (!is.na(covars)) {
    for (covar in covars) {
      metadata = metadata[!is.na(metadata[[covar]]),]
    }
    norm_assay = norm_assay[,metadata$GUID]
  }
  print(paste0('Dropped ', orig_size - nrow(metadata), ' inds due to missing data'))
  
  # get variable of interest
  f = factor(metadata[[comp_variable]])
  
  # generate formula
  if (!is.na(covars)) {
    form1 = as.formula(paste0('~0 + f +', paste(covars, collapse=" + ")))
  } else {
    form1 = as.formula('~0 + f')
  }
  design = model.matrix(form1, metadata)
  
  fit <- lmFit(norm_assay, design)
  print(contrast_pass)
  cont.matrix <- makeContrasts(contrasts=contrast_pass, levels=design)
  
  fit2  <- contrasts.fit(fit, cont.matrix)
  fit3  <- eBayes(fit2, trend = TRUE)
  
  # we only have one contrast, so it's in first column
  # leave all proteins for examination (p value cutoff 1)
  # same as FDR adjustment
  res <- topTable(fit3, coef=1, n = Inf, adjust="BH", p = 1)
  
  return(res)
}

# Simple example comparing Cases to controls across all subjects
# using Sex and s100b (glial marker staining) as covariates
# this should produce no significant DEPs though
example_limma_results = getLimmaResults(proteomics, small_metadata)








